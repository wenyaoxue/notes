# Object
* toString()
* equals() and hashCode()
  * override equals, have to override hashcode
  * equals -> same hash code
* finalize()

# wrapper classes
* Byte, Short, Integer, Long, Float, Double, Character, Boolean
* final classes
* object
* autoboxing and unboxing
  * expecting wrapper, give primitive, or vice versa
* direct super class number for numbers
  * constructor takes primitive variable
  * static `MIN_VALUE`, `MAX_VALUE`, `parseInt(strval)`
  * `intValue()`, `equals(VAR)`, `compareTo(VAR)`

# Strings
## String
* immutable
* String literal pool - create same string with literals = same object
* new operator, or using string methods = new string reference
* operators: +, += (but order of ops is left to right for same precedence)
### methods - return new objects
* equals(otherstr), equalsIgnoreCase(otherstr)
* length() - eg \t and \n are each one character
* toUpperCase(), toLowerCase()
* startsWith(string), endsWith(string), contains(string)
* trim(), replace(oldChar, newChar) (or string)
* charAt(index), indexOf(char), indexOf(string), indexOf(string, fromIndex)
* substring(startIndex), substring(startIndex, endIndex+1)
* static format(String, Object... args)
## StringBuilder
* methods same object
* construct with string or capacity or nothing
* length()
* capacity() - default 16
* append(val) - val can be any primitive, string, or StringBuilder
* indexOf(string)
* charAt(index)
* replace(startIndex, endIndex, string)
* deleteCharAt(index)
* delete(startIndex, endIndex+1)
* insert(index, string)
* substring(startIndex, endIndex+1) - only one that returns a new object
* reverse()
## StringTokenizer
* StringTokenizer(ORIGINALSTRING, DELIMITER)
* hasMoreTokens()
* nextToken()

# arrays
* fixed length
* all elements have the same type
* class is generated by the compiler
  * for different types - not related, but covariant
    * cannot do manual casts
    * but arrays are covariant: Subclass[] is a subtype of Superclass[]
      * BUT cannot store elements of different Subclasses in the variable, runtime error - ArrayStoreException
  * special initialization
  * equals and hashCode and toString, methods are not overridden, so by default ==, use Arrays class for expected behaviors
## SPECIAL declaration
* `TYPE[] arr;` or `TYPE arr[];`
* one pair of brackets per dimension, each pair can go either after type or after the variable name
  * can do `type[] var[]` - 2 levels
* cannot use generics without a special package
## SPECIAL instantiation
* `new TYPE[LENGTH];` - given default values (eg null for objects)
  * `new TYPE[innerlength][outerlength]`, `new TYPE[innerlength][]`
* `new TYPE[]{val, val, val};` or IF IN SAME STATEMENT AS DECLARATION just `{val, val, val};`
  * `{{1,2}, {}, {3}, null}`
* note ArrayIndexOutOfBoundsException vs NullPointerException
* valid length 
  * can have 0 elements
  * too many elements may get OutOfMemoryError, technically max is the max int value
  * multidimension: each element array can have a different length
```
int[] arr[] = new int[3][];
//not allowed: int[] arr[] = new int[][3];
int[] arr2[] = arr.clone();
System.out.println(Arrays.deepToString(arr));
System.out.println(Arrays.deepToString(arr2));
Object obj = "string";
String str = (String) obj;
String[] strarr = new Object[3];
Object[] objarr = strarr;
// System.out.println(strarr instanceof objarr);
```
## members
* `[index]` - may cause ArrayIndexOutOfBoundsException (runtime)
* length - read only
* `clone()`
  * returns a shallow copy

# Arrays
## static methods
* `equals(arr1, arr2)` <- only goes one level - `deepEquals(arr)`
* `hashcode(arr)` <- only goes one level - `deepHashcode(arr)`
* `copyOf(arr1, newLength)`
* `toString(arr)` <- only goes one level -  `deepToString(arr)`
* `copyOfRange(arr, indIncl, indExcl)`
* `arraycopy(arr1, srcPos, arr2, destPos, length)` ?
* `sort(arr)`
* `binarySearch(arr, key)`
* `asList(Object... arr)`
  * receives an array, returns a List - both will point to the same object, cannot add/remove elements

# Collections
## List and Set interfaces
  * constructor can take a List object
   * makes a shallow copy
  * method `toArray()` returns `Object[]`
    * method `toArray(new String[0])` returns `String[]` - array argument is just for establishing type, nothing else, must match type of ArrayList
    * independent of the List object
    * shallow copy (eg if elements are objects)
```
List<Integer> list = new ArrayList<Integer>(Arrays.asList(new Integer[]{1,2,3}));
System.out.println(list);
Integer[] arr = list.toArray(new Integer[0]);
System.out.println(Arrays.toString(arr));
```
## ArrayList
* add(obj), add(i, obj)
* Stored in the order added
* New ArrayList(Arrays.asList(val, val, val))
* Zero based index = allows duplicate elements
* Unlike normal array
  * Dynamic sizing
* good for retrieval
## LinkedList
* add(obj), addFirst(obj), addLast(obj)
* good for insertion
## Hashset – no duplicates allowed
* By default based on references I think, but if you override hashCode and equals on all the properties, then if 2 objects have the same values then it counts as duplicates
* Unpredictable order
  * Same each runtime
  * Relative order stays the same – not restructured, it looks like
* HashSet.add()
## TreeSet
* Natural ascending order
* Objects need to implement comparable
## Map
* Map<keytype, valtype> map = new HashMap<keytype, valtype>();
  * Eg valtype can be ArrayList<String>
* put(key, val);
* entrySet()
  * returns a collection of Map.Entry (or Map.Entry<Type, Type>)
    * Map.Entry has methods getKey(), getValue() 
  * not too predictable order
* No duplicate keys
* TreeMap sorted
## Sort
Collections.sort(Comparable)
Collections.sort(collection, Comparator)
## ArrayList
* util
* constructor can take initial capacity
* only stores objects
### methods
* add(value) - value should match type, may be autoboxed by compiler
  * index, value
  * index, otherlist
* get(index)
* set(index, value)
* remove(value) - first instance or index
* removeAll(otherlist)
* size()
* clear()
* isEmpty()
* contains(value)
* equals(otherlist)
* listIterator()
  * returns type ListIterator(type) which has methods hasNext() and next()
* forEach(consumer) - one param -> void
* sort() = sort(null) or sort(comparator) - 2 params -> int eg a.compareTo(b)
* removeIf(Predicate) - 1 param -> boolean
* stream() - returns `Stream<eletype>`
  * filter(Predicate)
  * toArray()
```
List<Integer> al = new ArrayList<Integer>(Arrays.asList(new Integer[]{1,2,3}));
        Object[] arr = al.stream().toArray();
        System.out.println(Arrays.toString(arr));
```

# Exceptions
* should have methods getMessage(), printStackTrace()
* Object -> Throwable ->
  * Exception ->
    * IOException ->
      * FileNotFoundException 
    * RuntimeException (unchecked) ->
      * ArithmeticException (eg divide by 0)
      * ArrayIndexOutOfBoundsException
      * ClassCastException 
      * IllegalArgumentException -> NumberFormatException
      * IllegalStateException
      * NullPointerException
  * Error (unchecked exceptions that you should not catch, handle, or try to recover from) ->
    * ExceptionInInitializerError - errors in static field or block
    * StackOverflowError - infinite loop
    * NoClassDefFoundError - class was available at compile time but not runtime, or because you handle something else
    * OutOfMemoryError 

# Dates and Times
* java.time.
* NO CONSTRUCTORS!
* EXCEPTIONS THROWN for invalid vals
* immutable
## LocalDate
  * now()
  * of(year, month, day)
## LocalTime
  * now()
  * of(hr, min, sec, nanoSecond)
## LocalDateTime
  * now()
  * of(year, month, day, hr, min)
## ZonedDateTime
  * now()
  * of(year, month, day, hr, min, sec, nanSec, ZoneId.of("America/Chicago"))
## all of the above
* all accept int, or enum from package with Month.JANUARY, ...
* plusDays(int) - returns a new object
  * Months, Years, Hours, Minutes, Seconds, Nanos
  * minus
  * plus(period) or plus(duration)
* equals(otherdate)
  * isBefore(otherDate), isAfter(otherdate)
## Period
  * between(date, date) or ofDays(int) or of(years, months, days)
  * getYears(), getMonths(), getDays()
## Duration
  * between(date, date) or ofHours(int)
  * getSeconds()
## DateTimeFormatter
* static ofPattern()
  * E day of week, M/L month (num/txt), d day of month, y year), h hr,m min, 'literals'
  * exceptions for symbols
