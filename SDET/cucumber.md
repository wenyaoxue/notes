cucumber acceptance automation can be used through java, ie in a maven project
# install
help > eclipse marketplace > cucumber eclipse plugin > install
# pom.xml maven dependencies
* https://mvnrepository.com/artifact/io.cucumber/cucumber-junit
* https://mvnrepository.com/artifact/io.cucumber/cucumber-picocontainer
* https://mvnrepository.com/artifact/io.cucumber/cucumber-java
* and selenium pom.xml maven dependencies
* and restassured pom.xml maven dependencies (except 1. instead of sl4j, log4j/log4j 2. no jackson-databind 3. also org.codehaus.groovy/groovy-all
# `.feature` files
* create in a folder `Feature` in project
* `#` comments
## `Feature:` - app/component name
## `Scenario:` - test name; or `Background:` - same structure, everything included will be performed before each scenario
## `Given` `When` `Then` 
* Background uses one phrase to represent many steps
* and any phrase, which will be used to annotate the implementations
### parameters
#### literal injection
* feature phrase includes `"LITERALSTRINGVALUE"` <-> implementation annotation phrase includes `{string}`
* implementation method takes and uses parameter type `String`
#### DataTable
* underneath phrase (must be on a new line), include data `| VALUE | VALUE |` - can break line and have more data in the same format, eg new row
* implementation method takes and uses parameter type `DataTable`
  * DataTable has method `asLists` - no arguments, returns type `List<List<String>>` - eg use to get(rowi).get(coli)
## `And` `But` - same functionality
## run
* right click > Run As > Cucumber Feature
  * scenarios will be performed (-> pass/fail)
	* if step definitions (APPLICATIONPageStepDefinition class) are not implemented, console output will include method stub snippets
* can be batch executed - see src/test/java/com.TestRunner
# src/test/java/com.StepDefinition
* AbstractPageStepDefinition.java - hold, initialize, and return WebDriver variable
* APPLICATIONPageStepDefinition.java
	* subclass of AbstractPageStepDefinition, getDriver()
 	* eg in each method (generated by running feature) have a few selenium statements, eg driver.findElement.click...
* other methods
  * annotated `@After`
    * will be executed after every scenario (where the class is used I think)
# src/test/java/com.TestRunner
* annotate class TestRunner_Main.java
  * `@RunWith(Cucumber.class)`
  * `@CucumberOptions(OPTIONSSEPARATEDBYCOMMAS)`
    * `features = {"NAMEOFFEATUREFOLDER/NAMEOFFEATUREFILE.feature"}`
    * `glue = "NAMEOFSTEPDEFINITIONPACKAGE"`
    * `dryRun=false` - pass/fail based on - false: performing scenarios, true: checking scenarios are implemented (if fail, Failure Trace window will include snippets for unimplemented methods)
    * `monochrome=true`
    * `plugin  = {"pretty","html:CucumberReport/Report.html"}` - after execution, refresh, this report file will be created
    * tags
    * ?? missed the slide
* run as junit test
# it appears:
* each scenario creates an instance of the stepdefinition implementation that the methods are found in (ie variable declaration and assignment in APPLICATION... whatever is reexecuted, abstract...def is not)
* scenarios are performed in order, ie if using the abstract page's driver = using the same browser
