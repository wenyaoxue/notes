cucumber acceptance automation can be used through java, ie in a maven project or through javascript, ie in a playwright project
# setup
## java
* help > eclipse marketplace > cucumber eclipse plugin > install
### pom.xml maven dependencies
* https://mvnrepository.com/artifact/io.cucumber/cucumber-junit
* https://mvnrepository.com/artifact/io.cucumber/cucumber-picocontainer
* https://mvnrepository.com/artifact/io.cucumber/cucumber-java
* and selenium pom.xml maven dependencies
* and restassured pom.xml maven dependencies (except 1. instead of sl4j, log4j/log4j 2. no jackson-databind 3. also org.codehaus.groovy/groovy-all
## javascript
* vsc > extensions > ... > install
  * Cucumber (Gherkin) Full Support (Alexander Krechik)
  * npm (Microsoft)
* open a new folder (create in file explorer), then terminal > new terminal >
  * `npm init`
  * `npm i playwright`
  * `npm i @cucumber/cucumber`
# `.feature` files
* create in a folder `Feature` in project
* `#` comments
## `Feature:` - app/component name
## `Scenario:` - action description \n + given when then structure; or `Background:` perform before each scenario or `Scenario Outline:` perform one scenario for each dataset (see parameters > DataTable > multi data)
## `Given` scenario precondition \n `When` user performs an action \n `Then` check expected result
* ie follow each keyword with a high level phrase, which will be used to annotate the implementations
* join phrases in a clause with `And`, `But` - same functionality
### parameters
* eg for input data (when) (could be file paths and positions (eg sheet, row, key)), expected vals (then), etc.
#### literal injection
* feature phrase includes `"LITERALSTRINGVALUE"` <-> implementation annotation phrase includes `{string}`
* implementation method takes and uses parameter type `String`
#### using a table in feature
* feature data format - each new line/row: `| VALUE | VALUE |` (i think it must be a regular table, same number of cols per row)
* single data: underneath phrase (must be on a new line), include feature data
  * implementation method takes and uses parameter type `DataTable`
  * DataTable has method `asLists` - no arguments, returns type `List<List<String>>` - eg use to get(rowi).get(coli)
* multi data:
  * add clause to the end of the Scenario Outline: `Examples: with multiple data` + new line + feature data
  	* in the first row, each column VALUE should be DATACOLTITLE
  * instead of `Scenario:`, use `Scenario Outline:`
  * see literal injection - LITERALSTRINGVALUE can include `<DATACOLTITLE>` to substitute in a value from the table
  * will generate one scenario for each example (num rows - 1 for column titles)
## run
### java
* right click > Run As > Cucumber Feature
  * scenarios will be performed (-> pass/fail)
	* if step definitions (APPLICATIONPageStepDefinition class) are not implemented, console output will include method stub snippets
#### batch execute? so far only single execute - src/test/java/com.TestRunner
* annotate class TestRunner_Main.java
  * `@RunWith(Cucumber.class)`
  * `@CucumberOptions(OPTIONSSEPARATEDBYCOMMAS)`
    * `features = {"NAMEOFFEATUREFOLDER/NAMEOFFEATUREFILE.feature"}`
    * `glue = "NAMEOFSTEPDEFINITIONPACKAGE"`
    * `dryRun=false` - pass/fail based on - false: performing scenarios, true: checking scenarios are implemented (if fail, JUnit Failure Trace window will include snippets for unimplemented methods)
    * `monochrome=true`
    * `plugin  = {"pretty","html:CucumberReport/Report.html"}` - after execution, refresh, this report file will be created
    * tags
    * ?? missed the slide
* run as junit test
### javascript
* in terminal `./node_modules/.bin/cucumber-js --exit` - appears to run all .feature files in a `features` folder (any level)
# feature phrase implementations
## java src/test/java/com.StepDefinition
* AbstractPageStepDefinition.java - hold, initialize, and return WebDriver variable
* APPLICATIONPageStepDefinition.java
	* subclass of AbstractPageStepDefinition, getDriver()
 	* eg in each method (generated by running feature) have a few selenium statements, eg driver.findElement.click...
* other methods
  * annotated `@After`
    * will be executed after every scenario (where the class is used I think)
  * annotated `@AfterAll`
    *  will be executed after all scenarios are completed
    *  must be a static method
## javascript, by default should also be in the features folder (any level)
### world.js - special file name
* set page and browser of this instance of the cucumber world
```
const { setWorldConstructor } = require("@cucumber/cucumber");
const playwright = require('playwright');
class CustomWorld {
    async openUrl(url) {
        const browser = await playwright.chromium.launch({
            headless: false,
        });
        const context = await browser.newContext();
        this.page = await context.newPage();
        await this.page.goto(url);
    }
}
setWorldConstructor(CustomWorld);
```
### APPLICATIONPageStepDefinition.js (any name)
* `const { Given, When, Then } = require("@cucumber/cucumber");`
* `Given`, `When`, `Then` are functions which each take the following arguments, in order:
  * string phrase to match feature
  * optional: options object, eg `{ timeout: 60 * 1000 }`
  * function, eg `async function () {}` where functions inside are playwright using cucumber world variables, eg
    * `await this.openUrl('http://manabie.com/');`
    * `await this.page.click('text=Career');`
    * `await this.page.click('text=View Openings');`
    * `await this.page.waitForSelector('text=Our Openings');`
    
# it appears:
* each scenario creates an instance of the stepdefinition implementation that the methods are found in (ie variable declaration and assignment in APPLICATION... whatever is reexecuted, abstract...def is not)
* scenarios are performed in order, ie if using the abstract page's driver = using the same browser
